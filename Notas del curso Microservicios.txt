***************************************
** NOTAS DEL CURSO DE MICROSERVICIOS **
***************************************

** REFERENCIAS WEB DEL CURSO:

UDEMY: Microservicios con Spring Boot y Spring Cloud Netflix Eureka
https://www.udemy.com/course/microservicios-con-spring-boot-y-spring-cloud/

Spring Tools 4 for Eclipse
https://spring.io/tools

Spring Data
https://spring.io/projects/spring-data

Spring Data JPA (BBDD transaccionales)
https://spring.io/projects/spring-data-jpa

Postman:
https://www.postman.com/
https://www.postman.com/downloads/

Spring cloud jaxb dependency:
https://mvnrepository.com/artifact/org.glassfish.jaxb/jaxb-runtime

Repositorio de Maven:
https://mvnrepository.com/

Spring Cloud Circuit Breaker:
https://cloud.spring.io/spring-cloud-static/spring-cloud-circuitbreaker/1.0.0.RELEASE/reference/html/

Spring Cloud Netflix:
https://docs.spring.io/spring-cloud-netflix/docs/current/reference/html/

** Zuul - Portal de entrada - Filtros que manejan el ciclo de vida:
PRE ==> Se ejecuta antes de que el request sea enrutado  ==> Se usa para pasar datos al request.
POST ==> Se ejecuta después de que el request haya sido enrutado  ==> Se usa para modificar la respuesta (típicamente las cabeceras). 
ROUTE ==> Se ejecuta durante el enrutado del request, aquí se resuelve la ruta  ==> Se usa para la comunicación con el microservicio.

** JSON Web Tokens:
https://jwt.io/
JWT: es un estándar abierto para implementar seguridad en las aplicaciones API Rest basado en tokens. El estándar RFC 7519 es una forma para representar
de forma segura reclamaciones que envía un cliente a un servidor y el servidor interpreta estas reclamaciones o claims que contienen datos (pero que no
sea información sensible). Este estándar permite decodificar ese código, verificar si es válido y también se encarga de generar este código a través 
de una palabra código secreto que tenemos configurado en nuestro servidor.

PARTES DEL JSON WEB TOKEN:
Ejemplo: 
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSM
eKKF2QT4fwpMeJf36POk6yJV_adQssw5c
(es decir, PARTE_1.PARTE_2.PARTE_3)
- PARTE_1: CABECERA (HEADER) con información sobre el algoritmo sobre el cual se va a codificar el token y el por otro lado el tipo de token.
- PARTE_2: LOS DATOS O INFORMACIÓN DEL USUARIO(PAYLOAD): "sub" que representa un identificador (ej. username), y luego el resto de datos (nombre, apellido, 
  email, etc), una fecha de creación y opcionalmente una fecha de expiración, información sobre los permisos, privilegios o roles del usuario.
- PARTE_3: VERIFICACIÓN DE LA FIRMA(VERIFY SIGNATURE), es la parte de seguridad. Requiere de un código secreto y sirve para verificar que el token no ha sido 
  manipulado. Codifica el header y los datos. También lo firma. 

** Spring Security:
https://spring.io/projects/spring-security
https://spring.io/projects/spring-security-oauth
* Spring Security provee caracterçisticas de seguridad para aplicaciones empresariales Java EE.
* Spring Security maneja componentes de "Autenticación" y "Autorización".
- Autenticación: se refiere al proceso de establecer un principal. Un principal significa un usuario, dispositivo o algún otro sistema el cual puede ejecutar 
  alguna acción en nuestro sistema. En general, permite a los principales autenticarse en base a cualquier proveedor de seguridad por ejemplo LDAP, Base de 
	datos relacional principalmente y Autenticación HTTP. 
- Autorización: se refiere al proceso de decidir si se otorga acceso a un usuario para realizar una acción dentro de la aplicación, es decir, para controlar 
  el acceso a los recursos de la aplicaciónpor medio de la asignación de roles y permisosa grupos de usuarios.

** OAuth2 de spring es un framework, es un protocolo estándar de autorización que permite a las aplicaciones de terceros (angular, react, android) autenticarse
con cuentas de usuario que están en otra aplicación, en un servicio HTTP externo, sin compartir toda la información del usuario y menos las credenciales. 
Tiene 2 partes: Authorization Server y el Resource Server (o servidor de recurso). 
- Authorization Server se encarga de la autenticaión del usuario, si es válida genera un token JWT de acceso y se lo provee al usuario.
	- Ruta url: POST/auth/token -> En la cabecera se pasa Authorization y Content-Type. En cuerpo se pasan las credenciales (grant_type, username y password).
- Resource Server se encarga de administrar los permisos y accesos a nuestras páginas y Api Rest (end points) que están con seguridad. Habilita el filtro de 
  spring OAuth2AuthenticationProcessingFilter que se utiliza para validar y dar acceso a una petición Http (o request) que viene desde un cliente. Este request
  es el que envía el token de acceso en las cabeceras. 
	- Ruta url ejemplo: GET/api/clientes -> En la cabecera se envía el atributo Authorization Bearer access_token

Spring Data JPA: 
https://spring.io/projects/spring-data-jpa
Spring Data JPA: Working with Spring Data Repositories:
https://docs.spring.io/spring-data/jpa/docs/2.4.3/reference/html/#repositories
Para crear los métodos de consulta personalizados:
Spring Data JPA: Working with Spring Data Repositories: Defining Query Methods:
https://docs.spring.io/spring-data/jpa/docs/2.4.3/reference/html/#repositories.query-methods.details
Spring Data JPA: JPA Repositories: Query Methods:
https://docs.spring.io/spring-data/jpa/docs/2.4.3/reference/html/#jpa.query-methods
 
Estándar HATEOAS es la abreviación de Hypermedia as the Engine of Application State(hipermedia como motor del estado de la aplicación): es una restricción de la 
arquitectura Api Rest. Cuando el servidor retorna el JSON también retorna otra información en forma de hipervínculos y recursos del API que le indica al cliente
cómo navegar,cómo encontrar la información.

CREAR EL JAR:
1. En la consola de comandos ponerse en la ruta del proyecto: cd C:\Users\nombreUsuario\SpringTS_workspace\cursoMicroservicios\springboot-servicio-commons
2. Ejecutar el wrapper: mvnw.cmd install
(con el comando "mvnw install" no me creaba el jar en el directorio target del proyecto)
3. Si ya existía un jar del proyecto previamente, ejecutar el wrapper: mvnw.cmd clean install
4. Ver el resultado (el jar): 
	 - Ir a C:\Users\nombreUsuario\.m2\repository\com\formacionbdi\springboot\app\commons\springboot-servicio-commons\0.0.1-SNAPSHOT\springboot-servicio-commons-0.0.1-SNAPSHOT.jar

GIT - volver a un commit del repositorio y continuar desde allí borrando lo posterior:
git reset <commit> --hard
git push -f origin master

Authorization tipo Basic: 'Basic' + Base64.encode('frontendapp' + ':' + '12345')

GENERAR UN NUEVO TOKEN DE ACCESO A PARTIR DEL REFRESH_TOKEN:
Puede ser antes de que caduque el token de acceso o una vez ya caducado.
Es conveniente que el refresh_token tenga un tiempo de validez mayor que el del access_token.
1. Levantar los proyectos: config - eureka - oauth - usuarios - zuul
2. Generar un token de acceso:
    	Método: POST
    	Authorization: TYPE --> Seleccionar Basic Auth
    	--Username: frontendapp  (está configurado en AuthorizationServerConfig)
    	--Password: 12345
    	Click en Headers o en Preview Request: se genera una cabecera > Temporary Headers: KEY Authorization de tipo Basic 
    	-- Body: x-www-form-urlencoded: 
    	--> KEY: username --> VALUE: admin
    	--> KEY: password --> VALUE: 12345
    	--> KEY: grant_type --> VALUE: password
    	Ejecutar: localhost:8090/api/security/oauth/token
    	Devuelve: el token de acceso (access_token) y también el refresh_token (que permite obtener un token de acceso actualizado).
3. Suponemos que e token de acceso ha expirado.
4. Copiamos el refresh_token.
5. Generar un token de acceso:
    	Método: POST
    	Authorization: TYPE --> Seleccionar Basic Auth
    	--Username: frontendapp  (está configurado en AuthorizationServerConfig)
    	--Password: 12345
    	Click en Headers o en Preview Request: se genera una cabecera > Temporary Headers: KEY Authorization de tipo Basic 
    	-- Body: x-www-form-urlencoded: 
    	--> KEY: grant_type --> VALUE: refresh_token
    	--> KEY: refresh_token --> VALUE: pegamos el refresh_token que hemos copiado.		
    	Ejecutar: localhost:8090/api/security/oauth/token
    	Devuelve: el nuevo token de acceso (access_token) y también un nuevo refresh_token (que permite obtener un token de acceso actualizado).

CORS: es el intercambio de recursos de origen cruzado (Cross-origin resource sharing).
Ejmplo: una aplicación cliente (ej. angular) que está en un dominio distinto y en un puerto distinto se quiere conectar/comunicar con nuestro backend, 
nuestras Api Rest con zuul server (que es nuestra puerta de entrada.)
CORS es un mecanismo que utiliza las cabeceras HTTP para permitir que una aplicación cliente que está en otro servidor, en otro dominio distinto al del 
backend tenga los permisos para acceder a los recursos del backend. En este caso a recursos protegidos con Spring Security, particularmente con el servidor de 
recurso que lo tenemos configurado en zuul.







** SOLUCIÓN DE PROBLEMAS:

Eclipse importación de librerías
https://es.stackoverflow.com/questions/15479/eclipse-importaci%C3%B3n-de-librer%C3%ADas

Can't create a spring starter project in spring tool suite
https://stackoverflow.com/questions/47390485/cant-create-a-spring-starter-project-in-spring-tool-suite

Why am I getting Unknown error in line 1 of pom.xml?
https://stackoverflow.com/questions/56142369/why-am-i-getting-unknown-error-in-line-1-of-pom-xml

M2E:
https://download.eclipse.org/technology/m2e/releases/

El proyecto del microservicio item2 está desarrollado con una versión más antigua de Spring Boot para que pueda
manejar Hystrix que está deprecated en la versión actual.

























